import json

let utils = imp "../utils.n"
let decodeError = imp "./error.n"

alias pub error = decodeError.error
let failure = decodeError.failure

/// A value that knows how to decode `JSON.value` values.
alias pub decoder[t] = json.value -> result[t, error]

/// Decode a JSON string into an N `str`.
let pub str: decoder[str] = [value: json.value] -> result[str, error] {
	return if let <string string> = value {
		ok(string)
	} else {
		err(failure("Expected a string value.", value))
	}
}

/// Decode a JSON string into an N `bool`.
let pub bool: decoder[bool] = [value: json.value] -> result[bool, error] {
	return if let <boolean bool> = value {
		ok(bool)
	} else {
		err(failure("Expected a boolean value.", value))
	}
}

/// Decode a JSON string into an N `int`.
let pub int: decoder[int] = [value: json.value] -> result[int, error] {
	if let <number number> = value {
		// HACK: Cast the float back to an int with `round` then back to a float by
		// exponentiation.
		let int: int = round(number)
		if number = int ^ 1 {
			return ok(int)
		} else {
			return err(failure("Expected an integer value.", value))
		}
	} else {
		return err(failure("Expected an integer value.", value))
	}
}

/// Decode a JSON string into an N `float`.
let pub float: decoder[float] = [value: json.value] -> result[float, error] {
	return if let <number float> = value {
		ok(float)
	} else {
		err(failure("Expected a float value.", value))
	}
}

// Decode a value that may be null into an N `maybe`.
let pub nullable = [[t] decoder: decoder[t] value: json.value] -> result[maybe[t], error] {
	if value = json.null {
		return ok(none)
	} else {
		let result = decoder(value)
		return if let <ok decoded> = result {
			ok(yes(decoded))
		} else {
			// TEMP: needs match
			// result
			err(decodeError.oneOf([]))
		}
	}
}

// TODO: list
// TODO: dict
// TODO: keyValuePairs
// TODO: oneOrMore

/// Decode a value from a specific property from a JSON object.
let pub field = [[t] key: str decoder: decoder[t] value: json.value] -> result[t, error] {
	if let <object map> = value {
		if let <yes value> = getValue(key, map) {
			let decoded = decoder(value)
			return if let <err error> = decoded {
				err(decodeError.field(key, error))
			} else {
				decoded
			}
		} else {
			return err(failure("Expected the property `" + key + "`.", value))
		}
	} else {
		return err(failure("Expected a JSON object.", value))
	}
}

// TODO: at

/// Decode a value from a specific property from a JSON object.
let pub index = [[t] index: int decoder: decoder[t] value: json.value] -> result[t, error] {
	if let <array list> = value {
		if let <yes value> = itemAt(index, list) {
			let decoded = decoder(value)
			return if let <err error> = decoded {
				err(decodeError.index(index, error))
			} else {
				decoded
			}
		} else {
			return err(failure("Expected item " + intInBase10(index) + ".", value))
		}
	} else {
		return err(failure("Expected a JSON array.", value))
	}
}

/// Deals with optional fields. Examples:
///
/// ```n
/// let json = "{ \"name\": \"Billy\", \"age\": 18 }"
///
/// decodeString(maybe(field("age", int)), json) = ok(yes(18))
/// decodeString(maybe(field("name", int)), json) = ok(none)
/// decodeString(maybe(field("height", float)), json) = ok(none)
///
/// decodeString(field("age", maybe(float)), json) = ok(none)
/// ```
let pub maybe = [
	[t]
	decoder: decoder[t]
	value: json.value
] -> result[maybe[t], error] {
	if let <ok decoded> = decoder(value) {
		ok(yes(decoded))
	} else {
		ok(none)
	}
}

/// Tries several decoders until one works.
let pub oneOf = [[t] decoders: list[decoder[t]] value: json.value] -> result[t, error] {
	let results = filterMap(
		[decoder: decoder[t]] -> maybe[result[t, error]] {
			return yes(decoder(value))
		},
		decoders
	)
	for (result in results) {
		if let <ok decoded> = result {
			return ok(decoded)
		}
	}
	let errors = (filterMap(
		[result: result[t, error]] -> maybe[error] {
			return if let <err error> = result {
				yes(error)
			} else {
				none
			}
		},
		results
	))
		|> decodeError.oneOf
		|> err
	return errors
}

/// Parse the given string into a JSON value and then run the decoder on it.
/// This will fail if the string is invalid JSON or if the decoder fails.
let pub decodeString = [[t] decoder: decoder[t] jsonStr: str] -> result[t, error] {
	if let <yes value> = json.parseSafe(jsonStr) {
		return decoder(value)
	} else {
		return jsonStr
			|> json.string
			|> failure("Invalid JSON syntax.")
			|> err
	}
}

/// Run a decoder on a `json.value`.
let pub decodeValue = [[t] decoder: decoder[t] value: json.value] -> result[t, error] {
	return decoder(value)
}

let E = utils.getError

/// Transform the output type of a decoder. Perhaps you only want the length of
/// a string:
///
/// ```n
/// let decodeStringLength: decoder[int] =
/// 	map(len, str)
/// ```
let pub map: [a, t] (a -> t) -> decoder[a] -> decoder[t] = [
	[a, t]
	mapFn: a -> t
	decoder: decoder[a]
	value: json.value
] -> result[t, error] {
	let result = decoder(value)

	return if let <ok decoded> = result {
		ok(mapFn(decoded))
	} else {
		// Unfortunately I can't just return result
		// result
		E(result)
			|> decodeError.oneOf
			|> err
	}
}

/// Tries using two decoders and combines them with the given map function into
/// a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias point = { x: float, y: float }
///
/// let decodePoint: decoder[point] =
/// 	map2(
/// 		point,
/// 		field("x", float),
/// 		field("y", float),
/// 	)
/// ```
let pub map2:
	[a, b, t]
	(a -> b -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[t]
= [
	[a, b, t]
	mapFn: a -> b -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value))

	if let <ok a>, <ok b> = results {
		return ok(mapFn(a, b))
	} else {
		let (resultA, resultB) = results
		let error = (E(resultA) + E(resultB))
			|> decodeError.oneOf
			|> err
		return error
	}
}

/// Tries using three decoders and combines them with the given map function
/// into a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias person = { name: str; age: int; height: float }
///
/// let decodePerson: decoder[person] =
/// 	map3(
/// 		person,
/// 		field("name", str),
/// 		at(["info", "age"], int),
/// 		at(["info", "height"], float),
/// 	)
/// ```
let pub map3:
	[a, b, c, t]
	(a -> b -> c -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[c]
	-> decoder[t]
= [
	[a, b, c, t]
	mapFn: a -> b -> c -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value), decoderC(value))

	if let <ok a>, <ok b>, <ok c> = results {
		return ok(mapFn(a, b, c))
	} else {
		let (resultA, resultB, resultC) = results
		let error = (E(resultA) + E(resultB) + E(resultC))
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map4 = [
	[a, b, c, d, t]
	mapFn: a -> b -> c -> d -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d> = results {
		return ok(mapFn(a, b, c, d))
	} else {
		let (resultA, resultB, resultC, resultD) = results
		let error = (E(resultA) + E(resultB) + E(resultC) + E(resultD))
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map5 = [
	[a, b, c, d, e, t]
	mapFn: a -> b -> c -> d -> e -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	decoderE: decoder[e]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value),
		decoderE(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d>, <ok e> = results {
		return ok(mapFn(a, b, c, d, e))
	} else {
		let (resultA, resultB, resultC, resultD, resultE) = results
		let error = (
			E(resultA)
				+ E(resultB)
				+ E(resultC)
				+ E(resultD)
				+ E(resultE)
		)
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map6 = [
	[a, b, c, d, e, f, t]
	mapFn: a -> b -> c -> d -> e -> f -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	decoderE: decoder[e]
	decoderF: decoder[f]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value),
		decoderE(value),
		decoderF(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d>, <ok e>, <ok f> = results {
		return ok(mapFn(a, b, c, d, e, f))
	} else {
		let (resultA, resultB, resultC, resultD, resultE, resultF) = results
		let error = (
			E(resultA)
				+ E(resultB)
				+ E(resultC)
				+ E(resultD)
				+ E(resultE)
				+ E(resultF)
		)
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map7 = [
	[a, b, c, d, e, f, g, t]
	mapFn: a -> b -> c -> d -> e -> f -> g -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	decoderE: decoder[e]
	decoderF: decoder[f]
	decoderG: decoder[g]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value),
		decoderE(value),
		decoderF(value),
		decoderG(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d>, <ok e>, <ok f>, <ok g> = results {
		return ok(mapFn(a, b, c, d, e, f, g))
	} else {
		let (
			resultA,
			resultB,
			resultC,
			resultD,
			resultE,
			resultF,
			resultG
		) = results
		let error = (
			E(resultA)
				+ E(resultB)
				+ E(resultC)
				+ E(resultD)
				+ E(resultE)
				+ E(resultF)
				+ E(resultG)
		)
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map8 = [
	[a, b, c, d, e, f, g, h, t]
	mapFn: a -> b -> c -> d -> e -> f -> g -> h -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	decoderE: decoder[e]
	decoderF: decoder[f]
	decoderG: decoder[g]
	decoderH: decoder[h]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value),
		decoderE(value),
		decoderF(value),
		decoderG(value),
		decoderH(value)
	)

	if let (
		<ok a>,
		<ok b>,
		<ok c>,
		<ok d>,
		<ok e>,
		<ok f>,
		<ok g>,
		<ok h>
	) = results {
		return ok(mapFn(a, b, c, d, e, f, g, h))
	} else {
		let (
			resultA,
			resultB,
			resultC,
			resultD,
			resultE,
			resultF,
			resultG,
			resultH
		) = results
		let error = (
			E(resultA)
				+ E(resultB)
				+ E(resultC)
				+ E(resultD)
				+ E(resultE)
				+ E(resultF)
				+ E(resultG)
				+ E(resultH)
		)
			|> decodeError.oneOf
			|> err
		return error
	}
}

// TODO: lazy
// TODO: value
// TODO: null
// TODO: succeed
// TODO: fail
// TODO: andThen
