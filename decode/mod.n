import json

let decodeError = imp "./error.n"

alias pub error = decodeError.error

let failure = decodeError.failure

/// A value that knows how to decode `JSON.value` values.
alias pub decoder[t] = json.value -> result[t, error]

/// Decode a JSON string into an N `str`.
let pub str: decoder[str] = [value: json.value] -> result[str, error] {
	return if let <string string> = value {
		ok(string)
	} else {
		err(failure("Expected a string value.", value))
	}
}

/// Decode a JSON string into an N `bool`.
let pub bool: decoder[bool] = [value: json.value] -> result[bool, error] {
	return if let <boolean bool> = value {
		ok(bool)
	} else {
		err(failure("Expected a boolean value.", value))
	}
}

/// Decode a JSON string into an N `float`.
let pub float: decoder[float] = [value: json.value] -> result[float, error] {
	return if let <number float> = value {
		ok(float)
	} else {
		err(failure("Expected a float value.", value))
	}
}

/// Decode a value from a specific property from a JSON object.
let pub field = [[t] key: str decoder: decoder[t] value: json.value] -> result[t, error] {
	if let <object map> = value {
		if let <yes value> = getValue(key, map) {
			let decoded = decoder(value)
			return if let <err error> = decoded {
				err(decodeError.field(key, error))
			} else {
				decoded
			}
		} else {
			return err(failure("Expected the property `" + key + "`.", value))
		}
	} else {
		return err(failure("Expected a JSON object.", value))
	}
}

/// Parse the given string into a JSON value and then run the decoder on it.
/// This will fail if the string is invalid JSON or if the decoder fails.
let pub decodeString = [[t] decoder: decoder[t] jsonStr: str] -> result[t, error] {
	if let <yes value> = json.parseSafe(jsonStr) {
		return decoder(value)
	} else {
		return err(failure("Invalid JSON syntax.", json.string(jsonStr)))
	}
}

/// Run a decoder on a `json.value`.
let pub decodeValue = [[t] decoder: decoder[t] value: json.value] -> result[t, error] {
	return decoder(value)
}

/// Tries using two decoders and combines them with the given map function into
/// a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias point = { x: float, y: float }
///
/// let decodePoint: decoder[point] =
/// 	map2(
/// 		point,
/// 		field("x", float),
/// 		field("y", float),
/// 	)
/// ```
let pub map2:
	[a, b, t]
	(a -> b -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[t]
= [
	[a, b, t]
	mapFn: a -> b -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value))

	if let <ok a>, <ok b> = results {
		return ok(mapFn(a, b))
	} else {
		let (resultA, resultB) = results

		return err(
			decodeError.oneOf(
				(if let <err error> = resultA { [error] } else { [] })
					+ (if let <err error> = resultB { [error] } else { [] })
			)
		)
	}
}

/// Tries using three decoders and combines them with the given map function
/// into a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias person = { name: str; age: int; height: float }
///
/// let decodePerson: decoder[person] =
/// 	map3(
/// 		person,
/// 		field("name", str),
/// 		at(["info", "age"], int),
/// 		at(["info", "height"], float),
/// 	)
/// ```
let pub map3:
	[a, b, c, t]
	(a -> b -> c -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[c]
	-> decoder[t]
= [
	[a, b, c, t]
	mapFn: a -> b -> c -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value), decoderC(value))

	if let <ok a>, <ok b>, <ok c> = results {
		return ok(mapFn(a, b, c))
	} else {
		let (resultA, resultB, resultC) = results

		return err(
			decodeError.oneOf(
				(if let <err error> = resultA { [error] } else { [] })
					+ (if let <err error> = resultB { [error] } else { [] })
					+ (if let <err error> = resultC { [error] } else { [] })
			)
		)
	}
}
