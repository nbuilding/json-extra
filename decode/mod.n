import json

/// A decoding error type that describes precisely how an error happened. This
/// can be used to make more elaborate visualizations of a decoding error. For
/// example, you could show a preview of the JSON object and highlight the
/// invalid parts in red.
type pub error = <field str error>
	| <index int error>
	| <oneOf list[error]>
	| <failure str json.value>

/// A value that knows how to decode `JSON.value` values.
alias pub decoder[t] = json.value -> result[t, error]

/// Decode a JSON string into an N `str`.
let pub str: decoder[str] = [value: json.value] -> result[str, error] {
	return if let <string string> = value {
		ok(string)
	} else {
		err(failure("Expected a string value.", value))
	}
}

/// Decode a JSON string into an N `bool`.
let pub bool: decoder[bool] = [value: json.value] -> result[bool, error] {
	return if let <boolean bool> = value {
		ok(bool)
	} else {
		err(failure("Expected a boolean value.", value))
	}
}

/// Decode a JSON string into an N `float`.
let pub float: decoder[float] = [value: json.value] -> result[float, error] {
	return if let <number float> = value {
		ok(float)
	} else {
		err(failure("Expected a float value.", value))
	}
}

/// Parse the given string into a JSON value and then run the decoder on it.
/// This will fail if the string is invalid JSON or if the decoder fails.
let pub decodeString = [[t] decoder: decoder[t] jsonStr: str] -> result[t, error] {
	if let <yes jsonVal> = json.parseSafe(jsonStr) {
		return decoder(jsonVal)
	} else {
		return err(failure("Invalid JSON syntax.", json.string(jsonStr)))
	}
}

/// Tries using three decoders and combines them with the given map function
/// into a single value of your choosing.
///
/// For example,
/// ```n
/// alias person = { name: str; age: int; height: float }
///
/// let decodePerson: decoder[person] =
/// 	map3(
/// 		person,
/// 		field("name", str),
/// 		at(["info", "age"], int),
/// 		at(["info", "height"], float),
/// 	)
/// ```
let pub map3:
	[a, b, c, t]
	(a -> b -> c -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[c]
	-> decoder[t]
= [
	[a, b, c, t]
	mapFn: a -> b -> c -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value), decoderC(value))

	if let <ok a>, <ok b>, <ok c> = results {
		return ok(mapFn(a, b, c))
	} else {
		let (resultA, resultB, resultC) = results

		return err(
			oneOf(
				(if let <err error> = resultA { [error] } else { [] })
					+ (if let <err error> = resultB { [error] } else { [] })
					+ (if let <err error> = resultC { [error] } else { [] })
			)
		)
	}
}
