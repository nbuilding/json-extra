import json

let utils = imp "../utils.n"
let decodeError = imp "./error.n"

alias pub error = decodeError.error
let failure = decodeError.failure

/// A value that knows how to decode `JSON.value` values.
alias pub decoder[t] = json.value -> result[t, error]

/// Decode a JSON string into an N `str`.
let pub str: decoder[str] = [value: json.value] -> result[str, error] {
	return if let <string string> = value {
		ok(string)
	} else {
		err(failure("Expected a string value.", value))
	}
}

/// Decode a JSON string into an N `bool`.
let pub bool: decoder[bool] = [value: json.value] -> result[bool, error] {
	return if let <boolean bool> = value {
		ok(bool)
	} else {
		err(failure("Expected a boolean value.", value))
	}
}

/// Decode a JSON string into an N `int`.
let pub int: decoder[int] = [value: json.value] -> result[int, error] {
	if let <number number> = value {
		// HACK: Cast the float back to an int with `round` then back to a float by
		// exponentiation.
		let int: int = round(number)
		if number = int ^ 1 {
			ok(int)
		} else {
			return err(failure("Expected an integer value.", value))
		}
	} else {
		return err(failure("Expected an integer value.", value))
	}
}

/// Decode a JSON string into an N `float`.
let pub float: decoder[float] = [value: json.value] -> result[float, error] {
	return if let <number float> = value {
		ok(float)
	} else {
		err(failure("Expected a float value.", value))
	}
}

// TODO: nullable
// TODO: list
// TODO: dict
// TODO: keyValuePairs
// TODO: oneOrMore

/// Decode a value from a specific property from a JSON object.
let pub field = [[t] key: str decoder: decoder[t] value: json.value] -> result[t, error] {
	if let <object map> = value {
		if let <yes value> = getValue(key, map) {
			let decoded = decoder(value)
			return if let <err error> = decoded {
				err(decodeError.field(key, error))
			} else {
				decoded
			}
		} else {
			return err(failure("Expected the property `" + key + "`.", value))
		}
	} else {
		return err(failure("Expected a JSON object.", value))
	}
}

// TODO: at

/// Decode a value from a specific property from a JSON object.
let pub index = [[t] index: int decoder: decoder[t] value: json.value] -> result[t, error] {
	if let <array list> = value {
		if let <yes value> = itemAt(index, list) {
			let decoded = decoder(value)
			return if let <err error> = decoded {
				err(decodeError.index(index, error))
			} else {
				decoded
			}
		} else {
			return err(failure("Expected item " + intInBase10(index) + ".", value))
		}
	} else {
		return err(failure("Expected a JSON array.", value))
	}
}

// TODO: maybe
// TODO: oneOf

/// Parse the given string into a JSON value and then run the decoder on it.
/// This will fail if the string is invalid JSON or if the decoder fails.
let pub decodeString = [[t] decoder: decoder[t] jsonStr: str] -> result[t, error] {
	if let <yes value> = json.parseSafe(jsonStr) {
		return decoder(value)
	} else {
		return jsonStr
			|> json.string
			|> failure("Invalid JSON syntax.")
			|> err
	}
}

/// Run a decoder on a `json.value`.
let pub decodeValue = [[t] decoder: decoder[t] value: json.value] -> result[t, error] {
	return decoder(value)
}

let E = utils.getError

/// Transform the output type of a decoder. Perhaps you only want the length of
/// a string:
///
/// ```n
/// let decodeStringLength: decoder[int] =
/// 	map(len, str)
/// ```
let pub map: [a, t] (a -> t) -> decoder[a] -> decoder[t] = [
	[a, t]
	mapFn: a -> t
	decoder: decoder[a]
	value: json.value
] -> result[t, error] {
	let result = decoder(value)

	return if let <ok decoded> = result {
		ok(mapFn(decoded))
	} else {
		// Unfortunately I can't just return result
		// result
		E(result)
			|> decodeError.oneOf
			|> err
	}
}

/// Tries using two decoders and combines them with the given map function into
/// a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias point = { x: float, y: float }
///
/// let decodePoint: decoder[point] =
/// 	map2(
/// 		point,
/// 		field("x", float),
/// 		field("y", float),
/// 	)
/// ```
let pub map2:
	[a, b, t]
	(a -> b -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[t]
= [
	[a, b, t]
	mapFn: a -> b -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value))

	if let <ok a>, <ok b> = results {
		return ok(mapFn(a, b))
	} else {
		let (resultA, resultB) = results
		let error = (E(resultA) + E(resultB))
			|> decodeError.oneOf
			|> err
		return error
	}
}

/// Tries using three decoders and combines them with the given map function
/// into a single value of your choosing.
///
/// For example,
///
/// ```n
/// alias person = { name: str; age: int; height: float }
///
/// let decodePerson: decoder[person] =
/// 	map3(
/// 		person,
/// 		field("name", str),
/// 		at(["info", "age"], int),
/// 		at(["info", "height"], float),
/// 	)
/// ```
let pub map3:
	[a, b, c, t]
	(a -> b -> c -> t)
	-> decoder[a]
	-> decoder[b]
	-> decoder[c]
	-> decoder[t]
= [
	[a, b, c, t]
	mapFn: a -> b -> c -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	value: json.value
] -> result[t, error] {
	let results = (decoderA(value), decoderB(value), decoderC(value))

	if let <ok a>, <ok b>, <ok c> = results {
		return ok(mapFn(a, b, c))
	} else {
		let (resultA, resultB, resultC) = results
		let error = (E(resultA) + E(resultB) + E(resultC))
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map4 = [
	[a, b, c, d, t]
	mapFn: a -> b -> c -> d -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d> = results {
		return ok(mapFn(a, b, c, d))
	} else {
		let (resultA, resultB, resultC, resultD) = results
		let error = (E(resultA) + E(resultB) + E(resultC) + E(resultD))
			|> decodeError.oneOf
			|> err
		return error
	}
}

let pub map5 = [
	[a, b, c, d, e, t]
	mapFn: a -> b -> c -> d -> e -> t
	decoderA: decoder[a]
	decoderB: decoder[b]
	decoderC: decoder[c]
	decoderD: decoder[d]
	decoderE: decoder[e]
	value: json.value
] -> result[t, error] {
	let results = (
		decoderA(value),
		decoderB(value),
		decoderC(value),
		decoderD(value),
		decoderE(value)
	)

	if let <ok a>, <ok b>, <ok c>, <ok d>, <ok e> = results {
		return ok(mapFn(a, b, c, d, e))
	} else {
		let (resultA, resultB, resultC, resultD, resultE) = results
		let error = (
			E(resultA)
				+ E(resultB)
				+ E(resultC)
				+ E(resultD)
				+ E(resultE)
		)
			|> decodeError.oneOf
			|> err
		return error
	}
}
